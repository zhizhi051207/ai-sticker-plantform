import { NextRequest, NextResponse } from "next/server";
import OpenAI from "openai";
import { createGame, getGame } from "@/lib/db";
import { getServerSession } from "next-auth";
import { authOptions } from "@/lib/auth-options";

export const runtime = "nodejs";

const openai = new OpenAI({
  baseURL: "https://openrouter.ai/api/v1",
  apiKey: process.env.OPENROUTER_API_KEY,
  defaultHeaders: {
    "HTTP-Referer": process.env.NEXTAUTH_URL || "http://localhost:3000",
    "X-Title": "AI Game Generator",
  },
});

const normalizeHtml = (content: string) => {
  let result = content.trim();
  if (result.startsWith("```")) {
    result = result
      .replace(/^```[a-zA-Z]*\n?/, "")
      .replace(/```\s*$/, "")
      .trim();
  }
  return result;
};

const isHtmlComplete = (content: string) => {
  const lower = content.toLowerCase();
  return lower.includes("</html>") || lower.includes("</body>");
};

const isPlayableHtml = (content: string) => {
  const lower = content.toLowerCase();
  const hasCanvas = lower.includes("<canvas");
  const hasEvent =
    lower.includes("addeventlistener") ||
    lower.includes("onkeydown") ||
    lower.includes("onkeyup") ||
    lower.includes("onpointer") ||
    lower.includes("onclick") ||
    lower.includes("ontouch") ||
    lower.includes("onmousedown") ||
    lower.includes("onmouseup");
  const hasLoop =
    lower.includes("requestanimationframe") ||
    lower.includes("setinterval") ||
    lower.includes("settimeout");
  const hasGameState = lower.includes("game") && lower.includes("score");
  return (hasCanvas && (hasEvent || hasLoop)) || (hasEvent && hasLoop) || hasGameState;
};


export async function POST(request: NextRequest) {
  try {
    const session = await getServerSession(authOptions);
    if (!session?.user?.email) {
      return NextResponse.json({ error: "Authentication required" }, { status: 401 });
    }

    const { gameId, mode, instruction, htmlContent } = await request.json();
    if (!gameId || typeof gameId !== "string") {
      return NextResponse.json({ error: "gameId is required" }, { status: 400 });
    }

    if (mode !== "ai" && mode !== "html") {
      return NextResponse.json({ error: "mode must be ai or html" }, { status: 400 });
    }

    const game = await getGame(gameId);
    if (!game) {
      return NextResponse.json({ error: "Game not found" }, { status: 404 });
    }

    const isOwner =
      (session.user.id && game.userId === session.user.id) ||
      game.user?.email === session.user.email;

    if (!isOwner) {
      return NextResponse.json({ error: "Not allowed" }, { status: 403 });
    }

    let finalHtml = "";

    if (mode === "ai") {
      if (!instruction || typeof instruction !== "string") {
        return NextResponse.json({ error: "instruction is required" }, { status: 400 });
      }

      if (!process.env.OPENROUTER_API_KEY) {
        return NextResponse.json({ error: "Server configuration error" }, { status: 500 });
      }

      const createEditCompletion = () =>
        openai.chat.completions.create({
          model: "google/gemini-3-flash-preview",
          provider: { order: ["openrouter"] },
          messages: [
            {
              role: "system",
              content:
                "You are a sticker illustrator. You will edit an existing SVG sticker. Apply the user's instructions to the provided SVG and return a full, valid SVG document. Preserve style consistency. Return ONLY SVG code.",
            },
            {
              role: "user",
              content: `Here is the current SVG:\n\n${game.htmlContent}\n\nEdit instructions: ${instruction}\n\nReturn the full updated SVG only.`,
            },
          ],
          temperature: 0.4,
          max_tokens: 8192,
        } as any);

      const completion = await createEditCompletion();
      let html = completion.choices[0].message.content || "";
      html = normalizeHtml(html);
      if (!isHtmlComplete(html)) {
        const retry = await createEditCompletion();
        let retryContent = retry.choices[0].message.content || "";
        retryContent = normalizeHtml(retryContent);
        if (isHtmlComplete(retryContent)) {
          html = retryContent;
        }
      }
      if (!isHtmlComplete(html)) {
        throw new Error("Generated HTML incomplete. Please retry with a clearer instruction.");
      }
      if (!isPlayableHtml(html)) {
        throw new Error("Generated HTML is not playable. Please ask for a playable game with controls and gameplay.");
      }
      if (!html) {
        throw new Error("No content generated by AI");
      }
      finalHtml = html;
    }

    if (mode === "html") {
      if (!htmlContent || typeof htmlContent !== "string") {
        return NextResponse.json({ error: "htmlContent is required" }, { status: 400 });
      }
      const normalized = normalizeHtml(htmlContent);
      if (!isHtmlComplete(normalized)) {
        return NextResponse.json({ error: "HTML must include </html> or </body>" }, { status: 400 });
      }
      if (!isPlayableHtml(normalized)) {
        return NextResponse.json({ error: "HTML must include playable game logic (controls/loop)." }, { status: 400 });
      }
      finalHtml = normalized;
    }

    const editedGame = await createGame({
      title: `${game.title} (edited)`
        .replace(/\s+/g, " ")
        .trim(),
      description: `Edited from: ${game.title}`,
      prompt: mode === "ai" ? `Edit: ${instruction}` : "Manual HTML edit",
      htmlContent: finalHtml,
      isPublic: game.isPublic,
      userId: session.user.email,
    });

    return NextResponse.json({
      success: true,
      gameId: editedGame.id,
      title: editedGame.title,
      htmlContent: editedGame.htmlContent,
    });
  } catch (error: any) {
    console.error("Game edit error:", error);
    return NextResponse.json(
      { error: "Failed to edit game", details: error.message || String(error) },
      { status: 500 }
    );
  }
}
